# 내일배움캠프 240510 TIL
Java 16일차
상속, 인터페이스
--------------------------------------------


## 클래스 간의 관계와 상속
📌 상속의 사전적 정의는 부모가 자식에게 물려주는 행위를 말합니다.
- 객체 지향 프로그램에서도 부모 클래스의 필드와 메서드를 자식 클래스에게 물려줄 수 있습니다.
- 상속을 사용하면 적은 양의 코드로 새로운 클래스를 작성할 수도 있고 공통적인 코드를 관리하여 코드의 추가와 변경이 쉬워질 수도 있습니다.
- 이러한 특성 때문에 상속을 사용하면 코드의 중복이 제거되고 재사용성이 크게 증가하여 생산성과 유지 보수성에 매우 유리해집니다.

- 상속
    📌 클래스 간의 상속은 extends 키워드를 사용하여 정의할 수 있습니다.
    public class 자식클래스 extends 부모클래스 {

    }
    - 상속의 키워드는 extends입니다. 눈치채셨나요? 🤔
        - 우리는 상속의 개념을 확장의 개념으로 이해해야 합니다.
        - 자칫하여 부모 클래스, 자식 클래스라는 용어에 현혹되어 ‘부모가 자식보다 큰 사람이니까 부모 클래스도 마찬가지로 자식 클래스 보다 큰 범위겠지?’라고 생각하는 순간 헷갈리기 시작합니다…
    - 헷갈리기 시작할 때마다 아래 그림을 항상 기억하세요! 그리고 아래 3 문장을 떠올리세요!
        1. 부모 클래스에 새로운 필드와 메서드가 추가되면 자식 클래스는 이를 상속받아 사용할 수 있다.
        2. 자식 클래스에 새로운 필드와 메서드가 추가되어도 부모 클래스는 어떠한 영향도 받지 않는다.
        3. 따라서 자식 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다.

- 클래스 간의 관계
    📌 클래스 간의 관계를 분석하여 관계 설정을 해줄 수 있습니다.
    - 상속관계 : is - a (”~은 ~(이)다”)
    - 포함관계 : has - a (”~은 ~을(를) 가지고 있다”)

    - 상속관계는 위에서 예제로 살펴본 스포츠카와 자동차도 있지만 한 가지 더 예를 들자면 고래와 포유류가 있습니다.
    - 위 공식에 대입해 보겠습니다.
        - 상속관계 : 고래는 포유류다 👍
        - 포함관계 : 고래는 포유류를 가지고 있다…? 🤔

- 포함관계
    📌 포함관계는 우리가 일전에 봤던 자동차와 타이어, 차 문, 핸들과의 관계라고 볼 수 있습니다.
    - 한번 위 공식에 대입해 보겠습니다.
    - 자동차는 타이어를 가지고 있다. 👍
    - 자동차는 차 문을 가지고 있다. 👍
    - 자동차는 핸들을 가지고 있다. 👍

- 단일 상속과 다중 상속
    📌 Java는 다중 상속을 허용하지 않습니다…
    - 다중 상속을 허용하면 복잡한 소프트웨어의 기능을 구현할 때 여러 개의 클래스를 상속받아 쉽게 구현할 수 있다는 장점이 있는데.. 왜? 허용하지 않을까요?
    - 왜냐하면 다중 상속을 허용하면 클래스 간의 관계가 복잡해지는 문제가 생기기 때문입니다.
    - 만약 자식 클래스에서 상속받는 서로 다른 부모 클래스들이 같은 이름의 멤버를 가지고 있다면?
    - 자식 클래스에서는 이 멤버를 구별할 수 있는 방법이 없다는 문제가 생깁니다.

- inal 클래스와 final 메서드
    📌 final 키워드를 클래스와 메서드에 선언하면 어떻게 될까요?
    public final class Car {}
    ...
    public class SportsCar extends Car{} // 오류가 발생합니다.
    - 클래스에 final 키워드를 지정하여 선언하면 최종적인 클래스가 됨으로 더 이상 상속할 수 없는 클래스가 됩니다.

    public class Car {
        public final void horn() {
            System.out.println("빵빵");
        }
    }

    ...

    public class SportsCar extends Car{
        public void horn() { // 오류가 발생합니다.
            super.horn();
        }
    }
    - 메서드에 final 키워드를 지정하여 선언하면 최종적인 메서드가 됨으로 더 이상 오버라이딩할 수 없는 메서드가 됩니다.

- Object
    📌 Object는 말 그대로 “객체”를 의미하는 단어이며 보통, Object 클래스를 의미합니다.
    - Object 클래스는 Java 내 모든 클래스들의 최상위 부모 클래스입니다.
    - 따라서, 모든 클래스는 Object의 메서드를 사용할 수 있습니다.
    - 또한 부모 클래스가 없는 자식 클래스는 컴파일러에 의해 자동으로 Object 클래스를 상속받게 됩니다.

    🧑‍💻 Object 클래스의 메서드를 몇 가지 소개해 드리겠습니다.
    - Object **clone()** : 해당 객체의 복제본을 생성하여 반환함.
    - boolean **equals(Object object)** : 해당 객체와 전달받은 객체가 같은지 여부를 반환함.
    - Class **getClass()** : 해당 객체의 클래스 타입을 반환함.
    - int **hashCode()** : 자바에서 객체를 식별하는 정수값인 해시 코드를 반환함.
    - String **toString()** : 해당 객체의 정보를 문자열로 반환함. & Object 클래스에서는 클래스이름 @해쉬코드값 리턴함.


## 오버라이딩
📌 부모 클래스로부터 상속받은 메서드의 내용을 재정의 하는 것을 오버라이딩이라고 합니다.
- 부모 클래스의 메서드를 그대로 사용 가능하지만 자식 클래스의 상황에 맞게 변경을 해야 하는 경우 오버라이딩을 사용합니다.
- 오버라이딩을 하기 위해서는 아래 조건들을 만족해야 합니다.
1. 선언부가 부모 클래스의 메서드와 일치해야 합니다.
2. 접근 제어자를 부모 클래스의 메서드 보다 좁은 범위로 변경할 수 없습니다.
3. 예외는 부모 클래스의 메서드 보다 많이 선언할 수 없습니다.

- super 와 super()
    - super
        📌 super는 부모 클래스의 멤버를 참조할 수 있는 키워드입니다.
        - 객체 내부 생성자 및 메서드에서 부모 클래스의 멤버에 접근하기 위해 사용될 수 있습니다.
        - 자식 클래스 내부에서 선언한 멤버와 부모 클래스에서 상속받은 멤버와 이름이 같을 경우 이를 구분하기 위해 사용됩니다.
        - 부모 클래스
            // 부모 클래스 Car
            String model; // 자동차 모델
            String color; // 자동차 색상
            double price; // 자동차 가격

        - 자식 클래스
            // 자식 클래스 SportsCar
            String model = "Ferrari"; // 자동차 모델
            String color = "Red"; // 자동차 색상
            double price = 300000000; // 자동차 가격

        - 자식 클래스의 메서드
            public void setCarInfo(String model, String color, double price) {
                super.model = model; // model은 부모 필드에 set
                super.color = color; // color는 부모 필드에 set
                this.price = price; // price는 자식 필드에 set
            }

            - 자식 클래스의 메서드를 호출하면 super 키워드로 접근한 부모 클래스의 model, color 필드에 매개변수의 값이 저장됩니다.
            - this 키워드로 접근한 자식 클래스의 price 필드에는 매개변수의 값이 저장됩니다.

- super()
    📌 super(…)는 부모 클래스의 생성자를 호출할 수 있는 키워드입니다.
    - 객체 내부 생성자 및 메서드에서 해당 객체의 부모 클래스의 생성자를 호출하기 위해 사용될 수 있습니다.
    - 자식 클래스의 객체가 생성될 때 부모 클래스들이 모두 합쳐져서 하나의 인스턴스가 생성됩니다.
    - 이때 부모 클래스의 멤버들의 초기화 작업이 먼저 수행이 되어야 합니다.
        - 따라서 자식 클래스의 생성자에서는 부모 클래스의 생성자가 호출됩니다.
        - 또한 부모 클래스의 생성자는 가장 첫 줄에서 호출이 되어야 합니다.
    - 부모 클래스 생성자
        // 부모 클래스 Car 생성자
        public Car(String model, String color, double price) {
            this.model = model;
            this.color = color;
            this.price = price;
        }

    - 자식 클래스 생성자
        // 자식 클래스 SportsCar 생성자
        public SportsCar(String model, String color, double price, String engine) {
             // this.engine = engine; // 오류 발생
            super(model, color, price);
            this.engine = engine;
        }

    - 자식 클래스 객체를 생성할 때 생성자 매개변수에 매개값을 받아와 super(…)를 사용해 부모 생성자의 매개변수에 매개값을 전달하여 호출하면서 부모 클래스의 멤버를 먼저 초기화합니다.
    - 오버로딩된 부모 클래스의 생성자가 없다고 하더라도 부모 클래스의 기본 생성자를 호출해야 합니다.
        - 따라서 눈에 보이지는 않지만 컴파일러가 `super();`를 자식 클래스 생성자 첫 줄에 자동으로 추가해 줍니다

## 추상 클래스
- 추상 클래스란?
    📌 클래스가 설계도라면 추상 클래스는 미완성된 설계도입니다.
    - abstract 키워드를 사용하여 추상 클래스를 선언할 수 있습니다.
        public abstract class 추상클래스명 {

        }

    - 추상 클래스는 추상 메서드를 포함할 수 있습니다.
        - 추상 메서드가 없어도 추상 클래스로 선언할 수 있습니다.
    - 추상 클래스는 자식 클래스에 상속되어 자식 클래스에 의해서만 완성될 수 있습니다.
    - 추상 클래스는 여러 개의 자식 클래스들에서 공통적인 필드나 메서드를 추출해서 만들 수 있습니다.

- 추상 메서드
    📌 추상 메서드는 아직 구현되지 않은 미완성된 메서드입니다.
    - abstract 키워드를 사용하여 추상 메서드를 선언할 수 있습니다.
    public abstract class 추상클래스명 {
    		abstract 리턴타입 메서드이름(매개변수, ...);
    }

    - 추상 메서드는 일반적인 메서드와는 다르게 블록{ }이 없습니다.
        - 즉, 정의만 할 뿐, 실행 내용은 가지고 있지 않습니다.

- 상 클래스 상속
    📌 추상 메서드는 extends 키워드를 사용하여 클래스에서 상속됩니다.
    public class 클래스명 extends 추상클래스명 {
    		@Override
        public 리턴타입 메서드이름(매개변수, ...) {
    		       // 실행문
        }
    }

    - 상속받은 클래스에서 추상 클래스의 추상 메서드는 반드시 오버라이딩 되어야 합니다.


## 인터페이스의 역할
📌 인터페이스의 역할에 대해 학습해 보겠습니다.
- 인터페이스는 두 객체를 연결해 주는 다리 역할을 해줍니다.
    - 사람과 삼성티비, 엘지티비 객체가 존재한다고 생각해 보겠습니다.
    - 사람 객체는 멀티 리모컨 인터페이스를 통해서 삼성티비 객체의 채널을 변경할 수 있습니다.
    - 이때 삼성티비가 아니라 엘지티비로 객체가 교체된다고 해도 채널을 변경할 수 있습니다.
- 상속 관계가 없는 다른 클래스들이 서로 동일한 행위 즉, 메서드를 구현해야 할 때 인터페이스는 구현 클래스들의 동일한 사용 방법과 행위를 보장해 줄 수 있습니다.
    - 인터페이스는 스팩이 정의된 메서드들의 집합입니다.
    - 인터페이스의 구현 클래스들은 반드시 정의된 메서드들을 구현해야 합니다.
    - 따라서 구현 클래스들의 동일한 사용 방법과 행위를 보장해 줄 수 있습니다.
    - 이러한 특징은 인터페이스에 다형성을 적용할 수 있게 만들어 줍니다.

- 인터페이스 선언
    📌 interface 키워드를 사용하여 인터페이스를 선언할 수 있습니다.
    public interface 인터페이스명 {

    }
    - 인터페이스는 클래스와 마찬가지로 public, default 접근 제어자를 지정할 수 있습니다.

- 인터페이스 구성
    📌 인터페이스의 멤버
    - 모든 멤버 변수는 public static final이어야 합니다.
        - 생략 가능합니다.
    - 모든 메서드는 public abstract이어야 합니다.
        - 생략 가능합니다. (static 메서드와 default 메서드 예외)
    - 생략되는 제어자는 컴파일러가 자동으로 추가해줍니다.

    public interface 인터페이스명 {
    		public static final char A = 'A';
        static char B = 'B';
        final char C = 'C';
        char D = 'D';

        void turnOn(); // public abstract void turnOn();
    }

- 인터페이스 구현
    📌 인터페이스는 추상 클래스와 마찬가지로 직접 인스턴스를 생성할 수 없기 때문에 클래스에 구현되어 생성됩니다.
    - implements 키워드를 사용하여 인터페이스를 구현할 수 있습니다.
    public class 클래스명 implements 인터페이스명 {
    			// 추상 메서드 오버라이딩
    			@Override
    	    public 리턴타입 메서드이름(매개변수, ...) {
    			       // 실행문
    	    }
    }
    - 인터페이스의 추상 메서드는 구현될 때 반드시 오버라이딩 되어야 합니다.
    - 만약 인터페이스의 추상 메서드를 일부만 구현해야 한다면 해당 클래스를 추상 클래스로 변경해 주면 됩니다.

- 인터페이스 상속
    📌 인터페이스 간의 상속이 가능합니다.
    - 인터페이스 간의 상속은 implements 가 아니라 extends 키워드를 사용합니다.
    - 인터페이스는 클래스와는 다르게 다중 상속이 가능합니다.

    public class Main implements C {

        @Override
        public void a() {
            System.out.println("A");
        }

        @Override
        public void b() {
    				System.out.println("B");
        }
    }

    interface A {
        void a();
    }
    interface B {
        void b();
    }
    interface C extends A, B { }

    - 인터페이스 C는 아무것도 선언되어 있지 않지만 인터페이스 A, B를 다중 상속받았기 때문에 추상 메서드 a, b를 갖고 있는 상태입니다.
    - 따라서 Main 클래스에서 인터페이스 C가 구현될 때 a, b 추상 메서드가 오버라이딩됩니다.
    - 또한 인터페이스의 구현은 상속과 함께 사용될 수 있습니다.


## 디폴트 메서드와 static 메서드
- 디폴트 메서드
    📌 디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드입니다.
    - 메서드 앞에 default 키워드를 붙이며 블럭{ }이 존재해야 합니다.
    - default 메서드 역시 접근 제어자가 public이며 생략이 가능합니다.
    - 추상 메서드가 아니기 때문에 인터페이스의 구현체들에서 필수로 재정의 할 필요는 없습니다.
public class Main implements A {

    @Override
    public void a() {
        System.out.println("A");
    }

    public static void main(String[] args) {
        Main main = new Main();
        main.a();

        // 디폴트 메서드 재정의 없이 바로 사용가능합니다.
        main.aa();
    }
}

interface A {
    void a();
    default void aa() {
        System.out.println("AA");
    }
}

- static 메서드
    📌 인터페이스에서 static 메서드 선언이 가능합니다.
    - static의 특성 그대로 인터페이스의 static 메서드 또한 객체 없이 호출이 가능합니다.
    - 선언하는 방법과 호출하는 방법은 클래스의 static 메서드와 동일합니다.
        - 접근 제어자를 생략하면 컴파일러가 public을 추가해 줍니다.
public class Main implements A {

    @Override
    public void a() {
        System.out.println("A");
    }

    public static void main(String[] args) {
        Main main = new Main();
        main.a();
        main.aa();
        System.out.println();

        // static 메서드 aaa() 호출
        A.aaa();
    }
}

interface A {
    void a();
    default void aa() {
        System.out.println("AA");
    }
    static void aaa() {
        System.out.println("static method");
    }
}