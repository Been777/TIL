# 내일배움캠프 240511 TIL
Java 17일차
예외처리, 제네릭
--------------------------------------------

## 오류 및 예외에 대한 이해
- **프로그램이 직면하는 문제 상황들**
    📌 아무리 좋은 프로그래머라도 모든 것을 컨트롤할 수는 없습니다. 완벽한 프로그램이란 것은 없을뿐더러, 완벽한 프로그램도 제어하지 못하는 문제는 발생합니다. 예를 들어 여러분이 특정한 숫자를 입력받아 그 숫자의 두 배를 반환하는 아주 간단하지만 완벽해 보이는 프로그램을 개발했다고 해도 문제는 발생합니다. 예를 들어 …
    🤬 : 사용자가 숫자가 아닌 문자를 입력한다거나,
    🤮: 여러분의 프로그램의 메모리가 감당할 수 없는 숫자가 입력된다거나,
    🤪: 여러분의 프로그램을 돌리는 컴퓨터에 메모리가 부족하다거나

    하는 상황이 있을 수 있겠죠. 이러한 문제 상황은 프로그램의 한 부분을 차지하고 있으며, 이번 장은 자바에서 이러한 문제 상황을 어떻게 다뤄야 할지 이야기합니다.

    힌트를 드리자면, 우리가 위에서 발생한 것 같은 문제를 “정의” 하는 것에서 시작합니다. 그리고 그 정의가 정교할수록 우리가 “대응”할 여지가 많아집니다. 예를 들어…

    🤬 : 사용자가 숫자가 아닌 입력을 할 상황을 예견해 예외로 규정하고,
    🤮🤪: 메모리가 부족한 상황을 정의해 이러한 상황을 오류로 규정한다면,

    우리가 예외 상황에 대한 처리를 코드로 미리 해둘 수 있고, 오류가 발생했다면 어떠한 오류와 함께 프로그램이 종료되었는지를 알게 돼서 해당 오류에 대응할 수 있습니다.

    숫자가 아닌 입력에는 오류메세지를 띄우고, 오류를 보고 난 이후에는 더 풍부한 메모리를 가진 컴퓨터에서 프로그램을 돌린다면, 아직도 완벽하지는 않지만 그래도 조금 더 완벽에 가까운 프로그램이겠죠?

- **오류(Error)🔥 vs 예외(Exception)🚨**
    📌 문제 상황에 대한 대응의 첫걸음은 문제를 “정의” 하는 것입니다. 프로그래밍 언어들은 문제 상황에 대응하는 프로세스를 갖추고 있고, 당연히 이러한 프로세스의 시작은 문제 상황에 대한 정의에서 시작합니다. 그리고 문제상황을 구분하기 위해서 사용하는 기준은 일반적으로 “회복 가능 여부”입니다.
    당연히 자바에서도 문제 상황에 대한 대응 프로세스를 갖추고 있으며, 자바 역시 문제상황을 오류와 예외로 정의하고 있습니다.
    - 오류(Error)는 일반적으로 회복이 불가능한 문제입니다.
        - 이는 시스템 레벨에서, 또는 주로 환경적인 이유로 발생합니다.
        - 코드의 문제로 발생하는 경우도 있지만, 일단 발생하는 경우 일반적으로 회복이 불가능합니다.
        - 에러가 발생한 경우 우리는 어떠한 에러로 프로그램이 종료되었는지를 확인하고 대응합니다.
    - 예외(Exception)는 일반적으로 회복이 가능한 문제입니다.
        - 회복이 가능하다는 전제는 우리가 “그 예외가 발생할 수 있다는 것을 인지하고, 대응했을 것입니다”.
        - 현실적으로 코드 레벨에서 할 수 있는 문제 상황에 대한 대응은 “예외 처리”에 속합니다.

 - **예외🚨의 종류**
     📌 코드 레벨에서 할 수 있는 문제 상황에 대한 대응은 “예외 처리”라고 말씀드린 만큼, 우리가 배워야 할 것 역시 예외가 더 많습니다. 그러기 위해서 예외의 종류를 조금 더 세부적으로 구분할 수 있습니다.

- **코드 실행 관점👁️에서 예외의 종류**
    - 컴파일이란?
        🤔 컴파일을 간략하게 소개하면, 여러분이 사용하는 언어는 컴퓨터가 알아듣지 못합니다. 그래서 프로그래밍 언어라는 특정한 규칙(문법)이 있는 언어를 사용하여 프로그램의 코드를 작성하는 것이고, 그 특정한 규칙이 있기 때문에 컴퓨터(기계)가 이해할 수 있는 코드로 번역이 가능합니다.

        여러분이 프로그래밍 언어로 작성한 코드가 컴퓨터가 이해할 수 있는 언어로 변환되는 것을 “**컴파일”**이라고 하며, 컴파일 된 코드는 컴퓨터가 이해할 수 있어서, 실행시킬 수 있는 코드 뭉치인 **“프로그램”**이라고 합니다.

    - 컴파일 에러(예외) 📂
        - .java 파일을 .class 파일로 컴파일할 때 발생하는 에러
        - 대부분 여러분이 자바 프로그래밍 언어의 규칙을 지키지 않았기 때문에 발생합니다.
        - 예를 들어 있지 않은 클래스를 호출한다거나, 접근이 불가능한 프로퍼티나 메소드에 접근한다거나 하는 경우에 발생합니다.
        - 컴파일 에러가 발생하는 경우 해결 방법은 문법에 맞게 다시 작성하는 것입니다.
    - 런타임 에러(예외) ❤️‍🔥
        - 우리가 주로 다루게 될 에러(예외)입니다.
        - 문법적인 오류는 아니라서, 컴파일은 잘 되었지만 “프로그램”이 실행 도중 맞닥뜨리게 되는 예외입니다.
- 예외**처리 관점▶️에서 예외의 종류**
    - 확인된 예외✅ (Checked Exception)
        - 컴파일 시점에 확인하는 예외입니다.
        - 반드시 예외 처리를 해줘야 하는 예외입니다.

        ⚠️ 컴파일 시점에 확인하는 예외라는 문구 때문에, 컴파일 에러와 헷갈리 시면 안 됩니다!
        우리가 이미 특정한 문제를 인지하고 있어서, 해당 예외를 정의해두었고, 정의해두었기 때문에 컴파일 하는 동안 이 예외에 대한 예외 처리를 했는지 확인(Check) 할 수 있는 예외입니다.

        ”즉 **Checked Exception**에 대한 예외 처리를 하지 않으면 **컴파일 에러**가 발생합니다.”

    - 미확인된 예외🚫 (Unchecked Exception)
        - 런타임 시점에 확인되는 예외입니다.
        - 예외 처리가 반드시 필요하지 않은 예외입니다.

        📌 아직 예외와 예외 상황에 대한 구분이 감이 오지 않으실 겁니다. 그래서 바로 아래에 예제 코드와 조금 더 많은 설명이 덧붙여져 있습니다.


## 예외 발생과 try-catch, finally 문
- 예외 처리의 흐름 미리 보기
    📌 너무 이론적인 이야기만 했으니, 우리가 실제로 예외 처리를 어떻게 하는지 알아보고 가려고 합니다. 아래의 예시에서 주의 깊게 봐야 할 것은

    1. 우리가 예외를 어떻게 정의하고,
    2. 예외가 발생할 수 있음을 알리고,
    3. 사용자는 예외가 발생할 수 있음을 알고 예외를 핸들링하는지

    의 흐름입니다. 그 과정에서 이번 단원에서 배워야 할 try, catch, finally, throw 와 같은 키워드들이 어떻게 사용되는지 보시면 됩니다.

- 예외 정의하기
    - 우리는 직접 다음과 같이 우리만의 에러를 정의할 수 있습니다.
    - 자세한 내용은 ‘3. 예외 클래스 구조 이해하기’에서 조금 더 다루니 지금은 아래와 같이 “예외 클래스를 만들어 예외를 정의” 한다고 이해하시면 될 것 같습니다.
    class OurBadException extends Exception {
    	public OurBadException() {
    		super("위험한 행동을 하면 예외처리를 꼭 해야합니다!");
    	}
    }

- 클래스를 만들고, 메서드를 만들며 우리의 메서드가 위험하다고 알리기(throw, throws)

    class OurClass {
        private final Boolean just = true;

    		// 신규 문법 throws!
        public void thisMethodIsDangerous() throws OurBadException {
            if (just) {
    						// 신규 문법 throw!
                throw new OurBadException();
            }
        }
    }
| throws |
메서드 이름 뒤에 붙어 이 메서드가 어떠한 예외사항을 던질 수 있는지 알려주는 예약어입니다.
메서드 안에서, 실제로 예외 객체를 던질 때 사용하는 예약어입니다.
| throw |
여러 종류의 예외사항을 적을 수 있습니다.
실제로 던지는 예외 객체 하나와 같이 써야 합니다.
일반 메서드의 return 키워드처럼 throw 아래의 구문들은 실행되지 않고, throw문과 함께 메서드가 종료됩니다.
    📌 우리가 메서드를 선언할 때, 이 메서드가 위험하다는 것을 미리 **예측**해야 합니다.
    그리고 예측이 되어 있다면, 실제로 throw 키워드와 함께 **이 메서드가 위험하다고 알려야 합니다.**

- 용어 다시 정리해 보기
    - 우리는 방금 예시에서 Checked Exception을 다뤘습니다
    - 예외가 발생하는 상황을 “인지” 했고, 어떠한 에러인지 “정의” 했습니다.
    - 우리는 메서드를 선언할 때 예외가 발생하는 위험한 메서드라는 것을 “알렸습니다 (throws/throw)”.
    - 우리가  checked exception을 정의하고, 알렸으니 이 메서드를 사용할 때 예외 처리를 하지 않으면 컴파일 에러가 발생합니다!



## Generic 알아보기
📌 제네릭은 처음 배우는 분들에게 상대적으로 조금 더 까다로운 개념과 문법을 가지고 있습니다. 지금은 제네릭에 대한 기본 개념을 학습하고, 실제로 사용하면서 조금 더 제네릭과 관련한 문법을 익혀나가는 것이 좋습니다.

- 제네릭의 효용
    - 첫 번째로 제네릭의 효용은 타입 언어에서 “중복되거나 필요 없는 코드를 줄여주는 것”입니다.
    - 두 번째 제네릭의 효용은 그러면서도 타입 안정성을 해치지 않는 것입니다.
- Step 1. 타입 언어에서의 중복되거나 필요 없는 코드?
    - 만약 우리가 자바스크립트나 파이썬과 같은 약타입 언어를 이용한다면 일은 간단합니다.
    - 기본적으로 타입을 지정 해 줄 필요가 없기에 하나의 함수만 구현하면 끝입니다.

    function plusReturnFunction(a, b) {
        return a + b;
    }

    const a = 1;
    const b = 2;
    const c = 1.1;
    const d = "hello";

    plusReturnFunction(a + b); // 3
    plusReturnFunction(a + c); // 2.1
    plusReturnFunction(a + d); // 1hello

    - 하지만 우리는 타입을 지정해 줘야 하는 언어를 사용합니다.
    - 그래서 똑같은 로직을 수행하는 함수를 타입을 지정해야 한다는 이유로 세 차례나 구현해야 하죠

    public class Generic {
        public String plusReturnFunction(int a, int b) { ... }

        public String plusReturnFunction(int a, long b) { ... }

        public String plusReturnFunction(int a, String b) { ... }
    }


- Step 2. 타입 안정성을 해치지 않는 것?
    - Step 1을 보고 제네릭을 사용하지 않고도 우회할 수 있는 방법이 있다고 생각하신 분이 있다면 아주 잘 따라오고 계신 겁니다.
    - 이런 류의 해결 방법이 있지 않을까요?

    public class Generic {
        public Object plusReturnFunction(Object a,Object b) { ... }
    }

    - 자바의 “거의 모든 것”은 객체이고, 객체라는 것은 Object 클래스를 상속합니다.
    - Object를 상속받기 때문에 위의 코드와 같이 작성을 한다면, (Wrapper 객체에 대한 설명이 조금은 필요하겠지만) 실제로 여러분은 타입과 상관없이 메서드 안에 두 파라미터를 전달하는 것은 가능할 거예요.
    - 하지만 이런 경우 타입 안정성이 침해받게 됩니다.
    - 여러분이 직접 메서드를 위와 같이 구현했기 때문에, 지금은 아주 작아 보이는 { … } 블럭 안에 모든 경우의 수를 대비해야 합니다.
    - 또한 우리가 구현한 메서드 내부는 아직도 타입에 지배받고 있습니다.
    - 결론적으로는 다음과 같은 문제들이 발생합니다.
        - 예를 들어 a 객체와 b 객체에 단항 연산자를 사용할 수 있을까요?
        - 또는 두 타입이 다르다면 연산자를 사용하기 위해 같은 타입으로 맞춰줘야 하는데, 어떠한 타입으로 맞출 수 있을까요? int? long?
        - 마지막으로 순서는 어떻게 할까요? int long을 형변환 해서 처리하는 로직의 코드를 작성했는데, long과 int로 들어오면 어떻게 할까요?
    - 타입의 논리로 동작하는 세상에서, 타입 안정성을 침해하는 행위를 했습니다. 그러한 대가로 우리는 잘 피해간 것처럼 보였지만, 형변환과 같은 부수적인 코드는 오히려 늘어났습니다.
    🤔 자바스크립트의 간결한 코드를 보고 억울하신가요?
    그러실 필요 전혀 없습니다. 사실 자바스크립트의 데이터도 타입의 논리에 따라 움직입니다.
    다만 내부적으로 그 타입을 “추론”해주고 있을 뿐입니다.
    결국은 방대하고 어려운 로직을 구현하게 된다면, 해당 추론하는 과정을 모두가 정확히 이해하고 실수하지 않아야 버그가 발생하지 않습니다.
    그리고 모두가 실수하지 않는 일은 절대 일어나지 않기 때문에, 프로덕션 레벨에서는 자바스크립트보다 “타입 스크립트”를 더 선호합니다.
    지금은 자바스크립트를 배우고 있는 여러분의 동료들도 결국 타입 스크립트를 배워야 할 상황이 오고, 제네릭과 타입을 결국 배워야 합니다.
    단언컨대 지금 먼저 배워두는 게 낫습니다.

- 제네릭 문법 살펴보기
    📌 기본적으로 제네릭을 사용하는 흐름을 따라가봅시다.

    // 1.
    public class Generic<T> {
    		// 2.
        private T t;
        // 3.
        public T get() {
            return this.t;
        }

        public void set(T t) {
            this.t = t;
        }

        public static void main(String[] args) {
    				// 4.
            Generic<String> stringGeneric = new Generic<>();
    				// 5.
            stringGeneric.set("Hello World");

            String tValueTurnOutWithString = stringGeneric.get();

            System.out.println(tValueTurnOutWithString);
        }
    }

    1. 제네릭은 클래스 또는 메서드에 사용할 수 있습니다. 클래스 이름 뒤에 <> 문법 안에 들어가야 할 타입 변수를 지정합니다.
        🤔 타입 변수의 이름을 T로 사용하는 이유는 일종의 컨벤션이기 때문입니다.
        당연히 컨벤션이기 때문에, 여러분이 원하시는 어떠한 변수를 넣어도 문제가 없습니다.
        다만 당연히 컨벤션이기 때문에,
        굳이 다른 이유가 없다면 T를 사용하는 게 협업에 유리하겠죠?
        이와 함께 자주 사용되는 변수명으로는 T,U,V, E 등이 있습니다.
    2. 선언 해둔 타입 변수는 해당 클래스 내에서 특정한 타입이 들어갈 자리에 대신 들어갈 수 있습니다. 2번에서는 private 프로퍼티인 t의 타입이 들어가야 할 자리에 들어갔네요
    3. 메서드의 리턴 타입에 들어가는 것 역시 마찬가지입니다.
    4. 여기부터는 제네릭을 통해 구현한 클래스를 사용하는 부분입니다, 클래스에 선언했기 때문에 인스턴스를 만들기 위해서 타입 변수에 들어갈 실제 변수의 값을 넣어줘야 합니다. 여기서는 String이네요
    5. 아까 타입 변수로 대체해뒀던 곳에 String이 들어가 있기 때문에, 이와 같이 사용할 수 있습니다.

## 2. Generic 문법 자세히 살펴보기

- 제네릭 용어 정리하기
    public class Generic<T> { ... }

    Generic<String> stringGeneric = new Generic<>();

    - Generic<T>의 클래스처럼, 제네릭을 사용한 클래스를 제네릭 클래스라고 합니다.
    - 제네릭에서 <>사이에 들어가는 변수명 T는 타입 변수라고 합니다.
    - Generic 클래스를 원시 타입이라고 합니다.

- 제네릭의 제한
    1. 객체의 static 멤버에 사용할 수 없습니다.
        static T get() { ... } // 에러

        static void set(T t) { ... } // 에러

        - 타입 변수는 인스턴스 변수로 간주되고, 모든 객체에 동일하게 동작해야 하는 static 필드 특성상 사용할 수 없습니다.
    2. 제네릭 배열을 생성할 수 없습니다.

- 제네릭의 문법
    1. 다수의 타입 변수를 사용할 수 있습니다.
        public class Generic<T, U, E> {
            public E multiTypeMethod(T t, U u) { ... }
        }

        Generic<Long, Integer, String> instance = new Generic();
        instance.multiTypeMethod(longVal, intVal);

    2. 다형성 즉 상속과 타입의 관계는 그대로 적용됩니다.
        1. 대표적으로 부모 클래스로 제네릭 타입 변수를 지정하고, 그 안에 자식 클래스를 넘기는 것은 잘 동작합니다.
    3. 와일드카드를 통해 제네릭의 제한을 구체적으로 정할 수 있습니다.
        public class ParkingLot<T extends Car> { ... }

        ParkingLot<BMW> bmwParkingLot = new ParkingLot();
        ParkingLot<Iphone> iphoneParkingLot = new ParkingLog(); // error!

        1. <? extends T> : T와 그 자손들만 사용 가능
        2. <? super T> : T와 그 조상들만 가능
        3. <?> : 제한 없음

        📌 이렇게 제한을 하는 이유는 다형성 때문입니다.
        위의 코드에서, T는 Car의 자손 클래스들이라고 정의했기 때문에,
        해당 클래스 내부에서 최소 Car 객체에 멤버를 접근하는 코드를 적을 수 있습니다.
        반대로 그러한 코드들이 있을 여지가 있기 때문에,
        Car 객체의 자손이 아닌 클래스는 제한하는 것이죠

    4. 메서드를 스코프로 제네릭을 별도로 선언할 수 있습니다.
        // 또는 ..
        static <T> void sort(List<T> list, Comparator<? super T> c) { ... }

        1. 이렇게 반환 타입 앞에 <> 제네릭을 사용한 경우, 해당 메서드에만 적용되는 제네릭 타입 변수를 선언할 수 있습니다.
        2. 타입 변수를 클래스 내부의 인스턴스 변수 취급하기 때문에 제네릭 클래스의 타입 변수를 static 메서드에는 사용할 수 없었지만, 제네릭 메소드의 제네릭 타입 변수는 해당 메소드에만 적용되기 때문에 메소드 하나를 기준으로 선언하고 사용할 수 있습니다.
        3. 같은 이름의 변수를 사용했다고 해도 제네릭 메소드의 타입 변수는 제네릭 클래스의 타입 변수와 다릅니다.

            public class Generic<T, U, E> {
            		// Generic<T,U,E> 의 T와 아래의 T는 이름만 같을뿐 다른 변수
                static <T> void sort(List<T> list, Comparator<? super T> c) { ... }
            }


## 참고 : Wrapper 객체
📌 객체 지향 프로그래밍에서는 모든 것들을 객체로 다뤄야 합니다.
하지만 성능상의 이유로 현실과 타협할 수밖에 없는 경우가 있습니다.

1. 우리는 자연스럽게 다음과 같은 원시 타입을 사용해 왔습니다.
2. char, int, long과 같은 것들은 실제로 “값” 이상의 의의를 가지지 않는 경우가 더 많기 때문에, 비용이 많이 드는 객체로 다루는 대신 원시 타입 값 그대로를 사용합니다.
3. 하지만 잘 생각해 보면, 우리가 그동안 굉장히 많은 개념들을 추상화 해 왔는데, 기본형의 자료들도 충분히 추상화가 가능할 것 같습니다.
4. 예를 들면 소수, 반올림, 정수와 같은 개념들이 있겠죠
5. 당연히 자바는 이러한 특징들을 추상화해서 객체화는 해뒀습니다. 다만 값 이상의 의의를 가지지 않는 경우에는 성능상의 이유로 원시 값 그대로를 사용할 뿐이죠
6. 결론적으로 객체 특성을 이용한 추상적인 기능을 사용하려거나, 기본형 값 대신 객체로 저장해야 하거나, 객체로의 “기능”이 필요할 때 우리는 원시형 값들을 잠시 객체로 만들어 사용할 수 있습니다.
7. 즉 기본값을 객체화해서 “감싼다”라는 의미로 이러한 객체들을 Wrapper Class라고 하는데, 위의 표처럼 대응됩니다.
8. 기본값을 객체화하는 것을 박싱이라고 하며, 객체를 다시 기본값으로 만드는 것을 언박싱이라고 합니다.
9. 이러한 것들을 조금 더 문법적으로 자연스럽게 보여주기 위해서 오토 박싱, 오토 언박싱이라는 것도 존재합니다.

    Integer num = new Integer(17);  // Boxing
    int n = num.intValue(); // UnBoxing

    Character ch = 'X'; // AutoBoxing
    char c = ch; // AutoUnBoxing

10. 박싱해서 객체화된 원시 값들은 이제 클래스처럼, 구현되어 있는 메소드들을 자유롭게 이용이 가능하고, 객체만 할 수 있는 것들을 할 수 있게 됩니다.